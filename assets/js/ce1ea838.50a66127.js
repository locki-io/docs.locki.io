"use strict";(globalThis.webpackChunkdocs_locki_io=globalThis.webpackChunkdocs_locki_io||[]).push([[8643],{8453(e,s,n){n.d(s,{R:()=>l,x:()=>a});var r=n(6540);const t={},i=r.createContext(t);function l(e){const s=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(i.Provider,{value:s},e.children)}},9360(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"app/scheduler/TASK_BOILERPLATE","title":"OCapistaine Task Boilerplate Documentation","description":"Overview","source":"@site/docs/app/scheduler/TASK_BOILERPLATE.md","sourceDirName":"app/scheduler","slug":"/app/scheduler/TASK_BOILERPLATE","permalink":"/docs/app/scheduler/TASK_BOILERPLATE","draft":false,"unlisted":false,"editUrl":"https://github.com/locki-io/docs.locki.io/tree/main/docs/app/scheduler/TASK_BOILERPLATE.md","tags":[],"version":"current","frontMatter":{}}');var t=n(4848),i=n(8453);const l={},a="OCapistaine Task Boilerplate Documentation",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Purpose",id:"purpose",level:2},{value:"Function Signature",id:"function-signature",level:2},{value:"Return Values",id:"return-values",level:2},{value:"Result Dictionary Structure",id:"result-dictionary-structure",level:2},{value:"Usage Pattern",id:"usage-pattern",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Recurring Task (Multiple Runs Per Day)",id:"recurring-task-multiple-runs-per-day",level:3},{value:"Skip Logic",id:"skip-logic",level:2},{value:"1. Task Already Completed",id:"1-task-already-completed",level:3},{value:"2. Task Already Running",id:"2-task-already-running",level:3},{value:"Redis Key Patterns",id:"redis-key-patterns",level:2},{value:"Lock Keys",id:"lock-keys",level:3},{value:"Success Keys",id:"success-keys",level:3},{value:"Error Handling Pattern",id:"error-handling-pattern",level:2},{value:"TaskError",id:"taskerror",level:3},{value:"Exception Handling Template",id:"exception-handling-template",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Always Check Skip Status",id:"1-always-check-skip-status",level:3},{value:"2. Add Custom Counters",id:"2-add-custom-counters",level:3},{value:"3. Track All Operations",id:"3-track-all-operations",level:3},{value:"4. Always Release Lock",id:"4-always-release-lock",level:3},{value:"Common Mistakes",id:"common-mistakes",level:2},{value:"Wrong: Not Checking Skip Status",id:"wrong-not-checking-skip-status",level:3},{value:"Wrong: Forgetting Lock Release",id:"wrong-forgetting-lock-release",level:3},{value:"Wrong: Setting Success Key for Recurring Tasks",id:"wrong-setting-success-key-for-recurring-tasks",level:3},{value:"Integration with Task Chain",id:"integration-with-task-chain",level:2},{value:"Summary",id:"summary",level:2}];function o(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"ocapistaine-task-boilerplate-documentation",children:"OCapistaine Task Boilerplate Documentation"})}),"\n",(0,t.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"_task_boilerplate()"})," function in ",(0,t.jsx)(s.code,{children:"app/services/tasks/__init__.py"})," provides standardized initialization, locking, and result handling for all scheduler tasks. This ensures consistent behavior across all tasks and simplifies implementation."]}),"\n",(0,t.jsx)(s.h2,{id:"purpose",children:"Purpose"}),"\n",(0,t.jsx)(s.p,{children:"The boilerplate handles:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Task Identification"}),": Generates unique task IDs for logging/tracking"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Redis Locking"}),": Prevents concurrent execution of the same task"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Success Keys"}),": Tracks task completion to avoid duplicate runs"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Result Dictionary"}),": Standardized result structure"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Skip Logic"}),": Automatically skips already-completed or running tasks"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'def _task_boilerplate(\n    task_name: str,\n    date_string: str = None,\n    skip_success_check: bool = False,\n) -> Tuple[redis.Redis, str, str, Dict[str, Any], str]:\n    """\n    Standard task initialization boilerplate.\n\n    Args:\n        task_name: Full task identifier (e.g., "task_contributions_analysis")\n        date_string: Date in YYYYMMDD format. Defaults to today.\n        skip_success_check: If True, skip success key check (for recurring tasks).\n\n    Returns:\n        tuple: (redis_conn, lock_key, success_key, result_dict, task_id)\n    """\n'})}),"\n",(0,t.jsx)(s.h2,{id:"return-values",children:"Return Values"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Value"}),(0,t.jsx)(s.th,{children:"Type"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"l"})}),(0,t.jsx)(s.td,{children:"Redis connection"}),(0,t.jsx)(s.td,{children:"Scheduler Redis connection (db=6) for locks/success keys"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"lock_key"})}),(0,t.jsx)(s.td,{children:"str"}),(0,t.jsxs)(s.td,{children:["Redis key for task locking (",(0,t.jsx)(s.code,{children:"lock:{task_name}:{date_string}"}),")"]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"success_key"})}),(0,t.jsx)(s.td,{children:"str"}),(0,t.jsxs)(s.td,{children:["Redis key for completion tracking (",(0,t.jsx)(s.code,{children:"success:{task_name}:{date_string}"}),")"]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"result"})}),(0,t.jsx)(s.td,{children:"dict"}),(0,t.jsx)(s.td,{children:"Pre-initialized result dictionary with standard fields"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"task_id"})}),(0,t.jsx)(s.td,{children:"str"}),(0,t.jsx)(s.td,{children:"Unique UUID (8 chars) for this task execution"})]})]})]}),"\n",(0,t.jsx)(s.h2,{id:"result-dictionary-structure",children:"Result Dictionary Structure"}),"\n",(0,t.jsx)(s.p,{children:"The boilerplate creates a result dictionary with:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'{\n    "task": task_name,           # Full task name\n    "date": date_string,         # Date being processed (YYYYMMDD)\n    "task_id": task_id,          # Unique execution ID\n    "status": "pending",         # pending | success | skipped | failed\n    "errors": [],                # List of error messages\n    "warnings": [],              # List of non-fatal warnings\n    "reason": None,              # Reason for skip/failure (optional)\n}\n'})}),"\n",(0,t.jsx)(s.h2,{id:"usage-pattern",children:"Usage Pattern"}),"\n",(0,t.jsx)(s.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'from app.services.tasks import TaskError, _task_boilerplate, REDIS_SUCCESS_TTL\n\ndef task_example(date_string: str = None) -> dict:\n    """\n    Example task using boilerplate.\n\n    Args:\n        date_string: Date in YYYYMMDD format\n\n    Returns:\n        dict: Task result with status\n\n    Raises:\n        TaskError: For critical failures\n    """\n    # 1. Call boilerplate\n    l, lock_key, success_key, result, task_id = _task_boilerplate(\n        "task_example", date_string\n    )\n\n    # 2. Check if already skipped\n    if result["status"] == "skipped":\n        return result\n\n    # 3. Add custom result fields\n    result["items_processed"] = 0\n    result["items_succeeded"] = 0\n\n    try:\n        # 4. Do your work here\n        for item in items_to_process:\n            try:\n                # Process item\n                result["items_processed"] += 1\n                result["items_succeeded"] += 1\n\n            except Exception as e:\n                error_msg = f"Failed processing {item}: {str(e)}"\n                print(error_msg)\n                result["errors"].append(error_msg)\n                result["items_processed"] += 1\n                continue\n\n        # 5. Check for failures\n        if result["errors"] and result["items_succeeded"] == 0:\n            result["status"] = "failed"\n            raise TaskError("failed", f"All items failed: {len(result[\'errors\'])} errors")\n\n        # 6. Mark success\n        result["status"] = "success"\n        l.set(success_key, "completed", ex=REDIS_SUCCESS_TTL)\n        return result\n\n    except TaskError:\n        raise  # Re-raise TaskErrors cleanly\n\n    except Exception as e:\n        print(f"Unexpected error: {e}")\n        result["status"] = "failed"\n        if not result["errors"]:\n            result["errors"].append(f"Unexpected error: {str(e)}")\n        raise TaskError("failed", f"Unexpected error: {str(e)}")\n\n    finally:\n        # 7. Always release lock\n        l.delete(lock_key)\n'})}),"\n",(0,t.jsx)(s.h3,{id:"recurring-task-multiple-runs-per-day",children:"Recurring Task (Multiple Runs Per Day)"}),"\n",(0,t.jsxs)(s.p,{children:["For tasks like ",(0,t.jsx)(s.code,{children:"task_odds"})," that run multiple times per day:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'def task_recurring(date_string: str = None) -> dict:\n    # Use skip_success_check=True to allow multiple runs\n    l, lock_key, success_key, result, task_id = _task_boilerplate(\n        "task_recurring", date_string, skip_success_check=True\n    )\n\n    if result["status"] == "skipped":\n        return result  # Still respects lock (concurrent run protection)\n\n    try:\n        # Task logic...\n        result["status"] = "success"\n        # Note: Don\'t set success key for recurring tasks\n        return result\n    finally:\n        l.delete(lock_key)\n'})}),"\n",(0,t.jsx)(s.h2,{id:"skip-logic",children:"Skip Logic"}),"\n",(0,t.jsx)(s.p,{children:"The boilerplate automatically handles two skip scenarios:"}),"\n",(0,t.jsx)(s.h3,{id:"1-task-already-completed",children:"1. Task Already Completed"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'if not skip_success_check and l.exists(success_key):\n    result["status"] = "skipped"\n    result["reason"] = "already_completed"\n    return l, lock_key, success_key, result, task_id\n'})}),"\n",(0,t.jsx)(s.h3,{id:"2-task-already-running",children:"2. Task Already Running"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'acquired = l.set(lock_key, task_id, ex=REDIS_LOCK_TIMEOUT, nx=True)\nif not acquired:\n    result["status"] = "skipped"\n    result["reason"] = "lock_held"\n    return l, lock_key, success_key, result, task_id\n'})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Important"}),': Always check if result status is "skipped" after calling boilerplate:']}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'l, lock_key, success_key, result, task_id = _task_boilerplate("task_name", date_string)\n\n# Early return if already skipped\nif result["status"] == "skipped":\n    return result\n'})}),"\n",(0,t.jsx)(s.h2,{id:"redis-key-patterns",children:"Redis Key Patterns"}),"\n",(0,t.jsx)(s.h3,{id:"lock-keys",children:"Lock Keys"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Format: ",(0,t.jsx)(s.code,{children:"lock:{task_name}:{date_string}"})]}),"\n",(0,t.jsxs)(s.li,{children:["TTL: 300 seconds (",(0,t.jsx)(s.code,{children:"REDIS_LOCK_TIMEOUT"}),")"]}),"\n",(0,t.jsx)(s.li,{children:"Purpose: Prevent concurrent execution"}),"\n",(0,t.jsxs)(s.li,{children:["Always deleted in ",(0,t.jsx)(s.code,{children:"finally"})," block"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"success-keys",children:"Success Keys"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Format: ",(0,t.jsx)(s.code,{children:"success:{task_name}:{date_string}"})]}),"\n",(0,t.jsx)(s.li,{children:"TTL: 86400 seconds (24 hours)"}),"\n",(0,t.jsx)(s.li,{children:"Purpose: Track task completion"}),"\n",(0,t.jsx)(s.li,{children:"Set after successful execution"}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"error-handling-pattern",children:"Error Handling Pattern"}),"\n",(0,t.jsx)(s.h3,{id:"taskerror",children:"TaskError"}),"\n",(0,t.jsxs)(s.p,{children:["Use ",(0,t.jsx)(s.code,{children:"TaskError"})," for controlled failures:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'raise TaskError("failed", error_message)\n'})}),"\n",(0,t.jsx)(s.h3,{id:"exception-handling-template",children:"Exception Handling Template"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'try:\n    # Main work\n    pass\n\nexcept TaskError:\n    raise  # Clean re-raise, already logged\n\nexcept redis.RedisError as e:\n    print(f"Redis error: {e}")\n    result["status"] = "failed"\n    result["errors"].append(f"Redis error: {str(e)}")\n    raise TaskError("failed", f"Redis error: {str(e)}")\n\nexcept Exception as e:\n    print(f"Unexpected error: {e}")\n    result["status"] = "failed"\n    if not result["errors"]:\n        result["errors"].append(f"Unexpected error: {str(e)}")\n    raise TaskError("failed", f"Unexpected error: {str(e)}")\n\nfinally:\n    l.delete(lock_key)  # ALWAYS release lock\n'})}),"\n",(0,t.jsx)(s.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(s.h3,{id:"1-always-check-skip-status",children:"1. Always Check Skip Status"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'l, lock_key, success_key, result, task_id = _task_boilerplate("task_name", date)\n\nif result["status"] == "skipped":\n    return result  # Early return\n'})}),"\n",(0,t.jsx)(s.h3,{id:"2-add-custom-counters",children:"2. Add Custom Counters"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'# Add task-specific counters\nresult["contributions_processed"] = 0\nresult["contributions_validated"] = 0\nresult["contributions_flagged"] = 0\n'})}),"\n",(0,t.jsx)(s.h3,{id:"3-track-all-operations",children:"3. Track All Operations"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'for contribution in contributions:\n    try:\n        # Process contribution\n        result["contributions_processed"] += 1\n\n        if is_valid:\n            result["contributions_validated"] += 1\n        else:\n            result["contributions_flagged"] += 1\n\n    except Exception as e:\n        result["errors"].append(str(e))\n        result["contributions_processed"] += 1\n'})}),"\n",(0,t.jsx)(s.h3,{id:"4-always-release-lock",children:"4. Always Release Lock"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"finally:\n    l.delete(lock_key)  # Critical - prevents deadlocks\n"})}),"\n",(0,t.jsx)(s.h2,{id:"common-mistakes",children:"Common Mistakes"}),"\n",(0,t.jsx)(s.h3,{id:"wrong-not-checking-skip-status",children:"Wrong: Not Checking Skip Status"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'# BAD: Continuing after skip\nl, lock_key, success_key, result, task_id = _task_boilerplate("task_name", date)\n# ... do work anyway ...\n\n# GOOD: Early return on skip\nl, lock_key, success_key, result, task_id = _task_boilerplate("task_name", date)\nif result["status"] == "skipped":\n    return result\n'})}),"\n",(0,t.jsx)(s.h3,{id:"wrong-forgetting-lock-release",children:"Wrong: Forgetting Lock Release"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"# BAD: No finally block\ntry:\n    # work\n    l.delete(lock_key)  # Only happens on success\n\n# GOOD: Always release\ntry:\n    # work\nfinally:\n    l.delete(lock_key)  # Always happens\n"})}),"\n",(0,t.jsx)(s.h3,{id:"wrong-setting-success-key-for-recurring-tasks",children:"Wrong: Setting Success Key for Recurring Tasks"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'# BAD: Setting success key blocks subsequent runs\ndef task_recurring(...):\n    ...\n    l.set(success_key, "completed", ex=86400)  # Blocks next run!\n\n# GOOD: Don\'t set success key for recurring tasks\ndef task_recurring(...):\n    ...\n    # No success key - task can run again\n'})}),"\n",(0,t.jsx)(s.h2,{id:"integration-with-task-chain",children:"Integration with Task Chain"}),"\n",(0,t.jsxs)(s.p,{children:["Tasks are orchestrated in ",(0,t.jsx)(s.code,{children:"app/services/scheduler/__init__.py"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'task_chain = [\n    {\n        "id": "task_contributions_analysis",\n        "func": task_contributions_analysis,\n        "depends_on": [],\n    },\n    # Future tasks with dependencies:\n    # {\n    #     "id": "task_rag_indexing",\n    #     "func": task_rag_indexing,\n    #     "depends_on": ["task_contributions_analysis"],\n    # },\n]\n'})}),"\n",(0,t.jsx)(s.p,{children:"Each task:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"Runs only if dependencies succeeded"}),"\n",(0,t.jsx)(s.li,{children:"Uses boilerplate for initialization"}),"\n",(0,t.jsx)(s.li,{children:"Skips if already completed or running"}),"\n",(0,t.jsx)(s.li,{children:"Raises TaskError on failure"}),"\n",(0,t.jsx)(s.li,{children:"Sets success key on completion"}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(s.p,{children:"The task boilerplate provides:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Consistent initialization across all tasks"}),"\n",(0,t.jsx)(s.li,{children:"Automatic locking and skip logic"}),"\n",(0,t.jsx)(s.li,{children:"Standardized result structure"}),"\n",(0,t.jsx)(s.li,{children:"Clear error handling patterns"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Use it for every scheduler task to ensure reliability, consistency, and maintainability."}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Last Updated:"})," February 2026"]})]})}function u(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);